"""
library / collection of helpers for imaging data, mainly generated by ScanImage,
compatibility for multiROIs ( = mesoscope)
"""

import sys, os
from pathlib import Path
import json

# https://pypi.org/project/scanimage-tiff-reader/
from ScanImageTiffReader import ScanImageTiffReader as imread
import tifffile

import numpy as np
import pandas as pd
from tqdm import tqdm

"""
#### ##     ##    ###     ######   ########     ######  ##       ####  ######  #### ##    ##  ######
 ##  ###   ###   ## ##   ##    ##  ##          ##    ## ##        ##  ##    ##  ##  ###   ## ##    ##
 ##  #### ####  ##   ##  ##        ##          ##       ##        ##  ##        ##  ####  ## ##
 ##  ## ### ## ##     ## ##   #### ######       ######  ##        ##  ##        ##  ## ## ## ##   ####
 ##  ##     ## ######### ##    ##  ##                ## ##        ##  ##        ##  ##  #### ##    ##
 ##  ##     ## ##     ## ##    ##  ##          ##    ## ##        ##  ##    ##  ##  ##   ### ##    ##
#### ##     ## ##     ##  ######   ########     ######  ######## ####  ######  #### ##    ##  ######
"""

def make_slices(coords, size):
    """
    creates quadratic slices at the coordinates of +- size
    can slice both xy images and txy stacks
    returns a list of slices

    TODO: to be generalized towards non-rectangular shapes
    """

    slices = []
    for (x,y) in coords:
        s = np.s_[...,x-size:x+size, y-size:y+size]
        slices.append(s)

    return slices

def tile_slices(Is, nrows, ncols=None):
    """ tiles sliced images on a grid 
    works with both xy and txy data """

    # infer data dimensionality
    n_slices = len(Is)
    n_dims = len(Is[0].shape)

    # finding first index that has valid slice
    s = np.array([I.shape for I in Is if I.shape])
    j = np.argmax(np.all(s != 0, axis=1))

    if n_dims == 3: # data is txy
        n_frames, size, _ = Is[j].shape
    if n_dims == 2:
        size, _ = Is[j].shape

    # shape setup
    if ncols is None:
        ncols = int(np.ceil(n_slices / nrows))

    # mem alloc
    if n_dims == 3: # data is txy
        Z = np.zeros((n_frames, int(nrows * size), int(ncols * size)))
    else: # data ix xy
        Z = np.zeros((int(nrows * size), int(ncols * size)))
    Z[:] = np.nan

    # make indices
    from itertools import product
    inds = list(product(range(nrows), range(ncols)))

    # fill Z
    for k in tqdm(range(n_slices), desc='tiling'):
        i,j = inds[k]
        try:
            if n_dims == 3:
                Z[:, i*size:(i+1)*size, j*size:(j+1)*size] = Is[k]
            else:
                Z[i*size:(i+1)*size, j*size:(j+1)*size] = Is[k]
        except:
            # FIXME when does it fail?
            pass

    return Z

"""
##     ## ######## ########    ###
###   ### ##          ##      ## ##
#### #### ##          ##     ##   ##
## ### ## ######      ##    ##     ##
##     ## ##          ##    #########
##     ## ##          ##    ##     ##
##     ## ########    ##    ##     ##
"""

""" ScanImage metadata related tools """

def get_n_frames(fname):
    """ fast(est?) way to count frames in a file without 
    loading it into memory """
    return len(tifffile.TiffFile(fname).pages)

def get_tstamps_for_frames(fname):
    """ uses the scanimage tiffreader to get image timestamps """
    reader = imread(fname)
    n_frames = get_n_frames(fname)
    t_stamps = np.zeros(n_frames)

    for i in range(n_frames):
        # the parser
        t  = np.float32(reader.description(i).split('\n')[3].split(' = ')[1])
        t_stamps[i] = t

    return t_stamps

def get_meta(fname):
    """ read metadata from ScanImage tif """
    fname = Path(fname)
    reader = imread(str(fname)) # amazing - this librarty needs str

    # read meta
    lines = reader.metadata().split('\n')
    split_ix = lines.index('')

    # json meta
    meta_path = fname.parent / (fname.stem + '_meta.json')
    with open(meta_path,'w') as fH:
        fH.writelines('\n'.join(lines[split_ix:]))

    with open(meta_path,'r') as fH:
        meta = json.load(fH)

    meta_si_path = fname.parent / (fname.stem + '_meta.txt')
    meta_si = lines[:split_ix]
    with open(meta_si_path,'w') as fH:
        fH.writelines('\n'.join(meta_si))

    return meta, meta_si

def read_float_from_meta(meta_si, key):
    """ simple float reader helper
    potential TODO: to be generalized towards other data types """

    for line in meta_si:
        if line.startswith(key):
            return float(line.split(' = ')[1])

def get_data(fname, meta=True):
    """ read data (and metadata) from ScanImage tif """

    fname = Path(fname)
    reader = imread(str(fname)) # amazing - this librarty needs str
    Data = reader.data()

    # just return data
    if meta == False:
        return Data

    # return metadata as well
    else:
        meta, meta_si = get_meta(fname)
        return Data, meta, meta_si



"""
##     ## ##     ## ##       ######## #### ########   #######  ####
###   ### ##     ## ##          ##     ##  ##     ## ##     ##  ##
#### #### ##     ## ##          ##     ##  ##     ## ##     ##  ##
## ### ## ##     ## ##          ##     ##  ########  ##     ##  ##
##     ## ##     ## ##          ##     ##  ##   ##   ##     ##  ##
##     ## ##     ## ##          ##     ##  ##    ##  ##     ##  ##
##     ##  #######  ########    ##    #### ##     ##  #######  ####
"""

""" ScanImage multiROI functionality related tools """


def split_mROIs(fname):
    """ slices a multiROI tiff from the mesoscope into individual tstacks """

    fname = Path(fname) # just in case

    # read data
    Data, meta, meta_si = get_data(fname)

    flyToTime = read_float_from_meta(meta_si,"SI.hScan2D.flytoTimePerScanfield")
    linePeriod = read_float_from_meta(meta_si,"SI.hRoiManager.linePeriod")

    # getting individual ROIsizes
    nROIs = len(meta['RoiGroups']['imagingRoiGroup']['rois'])
    xpx = []
    ypx = []
    for i in range(nROIs):
        xpx_, ypx_ = meta['RoiGroups']['imagingRoiGroup']['rois'][i]['scanfields']['pixelResolutionXY']
        xpx.append(xpx_)
        ypx.append(ypx_)
        
    # odd reshaping
    # calculating the number of lines to discard
    n_drop = flyToTime / linePeriod
    n_drop = int(np.ceil(n_drop))
    if n_drop % 2 == 1: # think again about this part - why would we need to require an even number of dropped lines?
        n_drop = n_drop + 1

    n_frames = get_n_frames(fname)
    
    # reshaping to keep compatibility for single page tiffs
    if n_frames == 1:
        Data = Data[np.newaxis,:]

    # mem allocate
    mROI_data = []
    for j in range(nROIs):
        mROI_data.append(np.empty(shape=(n_frames, ypx[j], xpx[j])))

    # slice
    for i in tqdm(range(n_frames), desc="slicing mROIs: %s" % Path(fname).stem):
        for j in range(nROIs):
            start_ix = np.int32(np.sum(ypx[:j])+j*n_drop)
            stop_ix = start_ix + ypx[j]
            mROI_data[j][i, :, :] = Data[i, start_ix:stop_ix,:]

    return mROI_data, meta

def split_and_save_mROIs(fname):
    """ splits a multiROI scan into individual files.
    WARNING - this writes a new tiff without the SI metadata
    TODO make this function store the metadata
    TODO double check: verify pixel value equivalence
    """

    fname = Path(fname)
    mROI_data, meta = split_mROIs(fname)
    nROIs = len(mROI_data)
    for i, ROI_data in enumerate(mROI_data):
        outpath = fname.parent / (fname.stem + '_ROI_%i.tif' % i)
        with open(outpath,'wb') as fH:
            tifffile.imwrite(fH,ROI_data.astype('int16'), bigtiff=True)

